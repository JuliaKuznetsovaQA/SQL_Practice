# База данных "Учебная аналитика по курсу"

# Содержание
[Навигатор по шагам курса](#T1)<br>
[Заполнение таблицы для навигации по ключевым словам](#T2)<br>
[Поиск по ключевым словам](#T3)<br>
[Выборка данных по нескольким условиям, оператор CASE](#T4)<br>
[Табличные выражения, оператор WITH](#T5)<br>
[Задание, вычисление прогресса пользователей](#T6)<br>
[Оконные функции, оператор OVER, ORDER BY](#T7)<br>
[Задание, среднее время выполнения урока](#T8)<br>
[Оконные функции, оператор OVER, PARTITION BY](#T9)<br>
[Задание, периодичность работы обучающегося с курсом](#T10)<br>
[Задание, статистика по всем попыткам обучающегося](#T11)<br>
<br>

### Логическая схема базы данных :

<img src="img/5_1.jpg">

<a name="T1"></a>

# Навигатор по шагам курса

Платформа Stepik представляет довольно скудную навигацию по шагам модуля. Очень трудно вспомнить, на каком шаге изучался тот или иной материал. База данных этого урока позволяет с помощью запросов реализовать удобный поиск нужных шагов.

### Задание
Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). Указать к какому уроку и модулю они относятся. Для этого вывести 3 поля:

в поле Модуль указать номер модуля и его название через пробел;
в поле Урок указать номер модуля, порядковый номер урока (lesson_position) через точку и название урока через пробел;
в поле Шаг указать номер модуля, порядковый номер урока (lesson_position) через точку, порядковый номер шага (step_position) через точку и название шага через пробел.
Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить "..."). Информацию отсортировать по возрастанию номеров модулей, порядковых номеров уроков и порядковых номеров шагов.

Фрагмент логической схемы базы данных:

<img src="img/5_2.jpg">

```sql
SELECT CONCAT(module_id, " ", LEFT(module_name, 14), "...") AS Модуль,
    CONCAT(module_id, ".", lesson_position, " ", LEFT(lesson_name, 12), "...") AS Урок,
    CONCAT(module_id, ".", lesson_position, ".", step_position, " ", step_name) AS Шаг
FROM module
    JOIN lesson USING(module_id)
    JOIN step USING(lesson_id)
WHERE step_name LIKE "%вложенн%запрос%"
ORDER BY 1, 2, 3;

+---------------------+---------------------+-------------------------------------------------------------+
| Модуль              | Урок                | Шаг                                                         |
+---------------------+---------------------+-------------------------------------------------------------+
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.2 Вложенный запрос, возвращающий одно значение          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.3 Использование вложенного запроса в выражении          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.4 Вложенный запрос, оператор IN                         |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.5 Вложенный запрос, операторы ANY и ALL                 |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.6 Вложенный запрос после SELECT                         |
| 1 Основы реляцио... | 1.5 Запросы корр... | 1.5.5 Добавление записей, вложенные запросы                 |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.7 Запросы для нескольких таблиц со вложенными запросами |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.8 Вложенные запросы в операторах соединения             |
| 2 Запросы SQL к ... | 2.3 Запросы корр... | 2.3.5 Запрос на обновление, вложенные запросы               |
+---------------------+---------------------+-------------------------------------------------------------+

```

<a name="T2"></a>

# Заполнение таблицы для навигации по ключевым словам.

Еще одна возможность улучшить навигацию по курсу - это реализация поиска шагов по ключевым словам. Для этого необходимо создать таблицу с терминами keyword, а затем связать ее с таблицей step через вспомогательную таблицу step_keyword. Каждая запись этой таблицы - это id шага и id встречающегося на этом шаге ключевого слова.

### **Задание**

Заполнить таблицу step_keyword следующим образом: если ключевое слово есть в названии шага, то включить в step_keyword строку с id шага и id ключевого слова. 

Фрагмент логической схемы базы данных:

<img src="img/cx_4_6.jpg">

### Пояснение

1. Чтобы проверить, есть ли ключевое слово в заголовке шага, можно использовать функцию:

INSTR(string_1, string_2)
которая возвращает позицию первого вхождения string_2 в string_1. Если вхождения нет - результат функции 0.

2. Обратите внимание, что некоторые ключевые слова, например IN, входят в INNER и JOIN. Нужно учитывать только отдельные слова, которые разделены в названии шага либо пробелом, либо запятой, либо открывающей скобкой.

3. Это задание можно решить с помощью регулярных выражений (комментарий  Алексея Карелина) или с помощью функции REGEXP_INSTR (комментарий Yury Popov).

### комментарий  Алексея Карелина:

REGEXP позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане REGEXP представляет более изощренный и комплексный способ фильтрации, нежели оператор LIKE. Это <a href="https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax">ссылка</a> на документацию.

REGEXP имеет похожий синтаксис:

`WHERE выражение [NOT] REGEXP регулярное выражение`

Регулярное выражение может принимать следующие специальные символы:

`^`   указывает на начало строки

`$`   указывает на конец строки

`.`    соответствует любому одиночному символу

`[символы]`    соответствует любому одиночному символу из квадратных скобок

`[начальный_символ-конечный_символ]` соответствует любому одиночному символу из диапазона символов

`|`     отделяет два шаблона строки, и значение должно соответствовать одному из этих шаблонов

Примеры REGEXP:

<ul>
<li>WHERE ProductName REGEXP 'Phone': строка должна содержать "Phone", например, iPhone X, Nokia Phone N, iPhone</li>

<li>WHERE ProductName REGEXP '^Phone': строка должна начинаться с "Phone", например, Phone 34, PhoneX</li>

<li>WHERE ProductName REGEXP 'Phone$': строка должна заканчиваться на "Phone", например, iPhone, Nokia Phone</li>

<li>WHERE ProductName REGEXP 'iPhone [78]';: строка должна содержать либо iPhone 7, либо iPhone 8</li>

<li>WHERE ProductName REGEXP 'iPhone [6-8]';: строка должна содержать либо iPhone 6, либо iPhone 7, либо iPhone 8</li>
</ul> 

Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":
```sql
SELECT * FROM Products

WHERE ProductName REGEXP 'Phone|Galaxy';
```

### комментарий Yury Popov:

`REGEXP_INSTR(string, pat)` делает то же самое, что и `INSTR(string1, string2)`, только вторым аргументом можно подставить регулярное выражение. Символ конца слова надо набирать так: `\\b`

Символ `\\b` применяется только в регулярных выражениях.

Символ `\\b` в SQL используется, чтобы обозначить границу слова, с которым этот символ используется.

То есть, этот символ указывает на то, что искомая подстрока отделена в строке либо пробелом, либо знаками препинания, либо находится в начале или конце строки.

Если `\\b` стоит в начале подстроки, например `"\\bIN"`, то регулярное выражение отберёт все строки, в которых перед IN стоит либо пробел, либо знаки препинания, либо строка начинается с IN ("INNER" также попадёт в выборку).

Если `\\b` стоит в конце подстроки, например `"IN\\b"`, то регулярное выражение отберёт все строки, в которых после IN стоит либо пробел, либо знаки препинания, либо строка заканчивается на IN ("INNER" в выборку не попадёт, но теперь будет отобран JOIN, так как он заканчивается на IN).

Если же поставить `\\b` с обеих сторон, то регулярное выражение отберёт все строки, которые удовлетворяют обоим вышеуказанным пунктам. Таким образом, указать \\b слева и справа от подстроки, то регулярное выражение отберёт все строки, в которых подстрока идёт отдельным словом. То есть регулярное выражение `REGEXP '\\bIN\\b'` отберёт все строки, в которых IN встречается самостоятельно, в том числе в начале или конце строки.

```sql
SELECT step_name, keyword_name
FROM keyword CROSS JOIN step
WHERE REGEXP_INSTR(step_name, CONCAT('\\b', keyword_name, '\\b'))
ORDER BY keyword_id;

INSERT INTO step_keyword
SELECT step_id, keyword_id
FROM keyword CROSS JOIN step
WHERE REGEXP_INSTR(step_name, CONCAT('\\b', keyword_name, '\\b'))
ORDER BY keyword_id;

SELECT * FROM step_keyword;

результат запроса на выборку:

+--------------------------------------------------------------+--------------+
| step_name                                                    | keyword_name |
+--------------------------------------------------------------+--------------+
| Вложенный запрос после SELECT                                | SELECT       |
| Соединение INNER JOIN                                        | INNER        |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | LEFT         |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | RIGHT        |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | OUTER        |
| Перекрестное соединение CROSS JOIN                           | JOIN         |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | JOIN         |
| Соединение INNER JOIN                                        | JOIN         |
| Перекрестное соединение CROSS JOIN                           | CROSS        |
| Выборка данных по условию, групповые функции, WHERE и HAVING | WHERE        |
| Выборка данных по условию, групповые функции, WHERE и HAVING | HAVING       |
| Выборка данных, групповые функции SUM и COUNT                | SUM          |
| Выборка данных, групповые функции MIN, MAX и AVG             | AVG          |
| Выборка данных c вычислением, групповые функции, AVG         | AVG          |
| Выборка данных, групповые функции SUM и COUNT                | COUNT        |
| Выборка данных, групповые функции MIN, MAX и AVG             | MIN          |
| Выборка данных по условию, групповые функции, MIN            | MIN          |
| Выборка данных, групповые функции MIN, MAX и AVG             | MAX          |
| Операция соединение, использование USING()                   | USING        |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2 | UNION        |
| Задание. Работа с архивной таблицей, оператор UNION, часть 1 | UNION        |
| Вложенный запрос, операторы ANY и ALL                        | ALL          |
| Вложенный запрос, операторы ANY и ALL                        | ANY          |
| Вложенный запрос, оператор IN                                | IN           |
| Выборка данных, операторы BETWEEN, IN                        | IN           |
| Выборка данных, оператор LIKE                                | LIKE         |
| Выборка данных, операторы BETWEEN, IN                        | BETWEEN      |
+--------------------------------------------------------------+--------------+

Сама таблица step_keyword:

+---------+------------+
| step_id | keyword_id |
+---------+------------+
| 38      | 1          |
| 81      | 3          |
| 82      | 4          |
| 82      | 5          |
| 82      | 6          |
| 81      | 7          |
| 82      | 7          |
| 83      | 7          |
| 83      | 8          |
| 47      | 10         |
| 47      | 11         |
| 42      | 15         |
| 43      | 16         |
| 44      | 16         |
| 42      | 17         |
| 43      | 18         |
| 46      | 18         |
| 43      | 19         |
| 88      | 26         |
| 112     | 27         |
| 113     | 27         |
| 37      | 28         |
| 37      | 29         |
| 18      | 30         |
| 36      | 30         |
| 19      | 31         |
| 18      | 32         |
+---------+------------+

```

<a name="T3"></a>

# Поиск по ключевым словам

### **Задание**

Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова `MAX` и `AVG` одновременно. Для шагов указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел. Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать Шаг. Информацию отсортировать по первому столбцу в алфавитном порядке.

### Пояснение

В таблице `step_keyword` хранится информация о том, какие ключевые слова в каких шагах используются. При этом ключевое слово может быть связано с шагом, в названии которого этого ключевого слова нет. 

Фрагмент логической схемы базы данных:

<img src="img/cx_3_5.jpg">

```sql
SELECT CONCAT(module_id, ".", lesson_position, ".", IF(step_position < 10, CONCAT('0', step_position), step_position), " ", step_name) AS Шаг
FROM module
    JOIN lesson USING(module_id)
    JOIN step USING(lesson_id)
    JOIN step_keyword USING(step_id)
    JOIN keyword USING(keyword_id)
WHERE keyword_name = 'AVG' OR keyword_name = 'MAX'
GROUP BY step_id
HAVING COUNT(keyword_name) = 2 
ORDER BY 1;

+---------------------------------------------------------+
| Шаг                                                     |
+---------------------------------------------------------+
| 1.3.04 Выборка данных, групповые функции MIN, MAX и AVG |
| 1.4.06 Вложенный запрос после SELECT                    |
+---------------------------------------------------------+

```

<a name="T4"></a>

# Выборка данных по нескольким условиям, оператор CASE

С помощью оператора `CASE` можно в зависимости от нескольких условий получить один из нескольких результатов.

Оператор `CASE` записывается в виде:

`CASE  
     WHEN логическое_выражение_1 THEN выражение_1
     WHEN логическое_выражение_2 THEN выражение_2
     ...
     ELSE выражение_else   
END` 
Раздел `ELSE` является необязательным.

Выполняется оператор `CASE` так:

вычисляется `логическое_выражение_1`, если оно истинно, то результатом оператора является `выражение_1`, если ложно - выполнение оператора продолжается;
вычисляется `логическое_выражение_2`, если оно истинно, то результатом оператора является `выражение_2`, если ложно - выполнение оператора продолжается;
если все логические выражения оказались ложными, то результат оператора - `выражение_else`
`CASE` можно использовать в  `SELECT, UPDATE, DELETE, SET, WHERE, ORDER BY, HAVING` - всюду, где можно использовать выражения.

Пример

Отнести каждого студента к группе,  в зависимости от пройденных заданий:

<img src="img/5_2_2.jpg">

Пройденными считаются задания с хотя бы одним верным ответом. В таблице `step_student` сохраняются все попытки пользователей, следовательно, могут быть пользователи, у которых на одно задание есть несколько верных попыток.

### Фрагмент логической схемы базы данных:

<img src="img/5_2_1.jpg">

###  Шаг 1. 
Выведем всех студентов и все шаги, которые они прошли с результатом "correct". Этот шаг обязателен, чтобы не учитывать  правильные решения несколько раз.

Запрос:
```sql
SELECT student_name, step_id
FROM 
    student 
    INNER JOIN step_student USING(student_id)
WHERE result = "correct"
GROUP BY student_name, step_id;
```

###  Шаг 2. 
Посчитаем, сколько шагов прошел каждый студент.

Запрос:

```sql
SELECT student_name, count(*) as rate
FROM 
    (
     SELECT student_name, step_id
     FROM 
         student 
         INNER JOIN step_student USING(student_id)
     WHERE result = "correct"
     GROUP BY student_name, step_id
    ) query_in
GROUP BY student_name
ORDER BY 2;
```
### Шаг 3. 
Отнести каждого студента к группе в зависимости от пройденных шагов.

 Запрос:

```sql
SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1;
```
    
### Задание

Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество. Указать границы интервала.

### Пояснение
Если логическое выражения во всех WHEN представляет собой сравнение на равенство с некоторым значением, то оператор CASE можно записать в виде:

`CASE столбец 
     WHEN значение_1 THEN выражение_1
     WHEN значение_2 THEN выражение_2
     ...
     ELSE значение_else   
END`

Это задание можно решить и другим способом (без  `CASE`). Для этого можно создать таблицу с интервалами и использовать ее в запросе.

Решение:

```sql
SELECT Группа, 
    CASE 
     WHEN Группа = "I" THEN 'от 0 до 10'
     WHEN Группа = "II" THEN 'от 11 до 15'
     WHEN Группа = "III" THEN 'от 16 до 27'
     WHEN Группа = "IV" THEN 'больше 27'   
END AS Интервал, 
    COUNT(student_name) AS Количество

FROM (SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1) Q2
GROUP BY 1    
    ;

```
